---
layout: default
title: 第一部
brothers:
 - second-page.md
---

## はじめに
まずc++を書く上でいくつか心がけて欲しいことがあります.  

* **速さより, 読みやすさを優先する**  
  高速で動くコードより人が読みやすいコードを書くようにしましょう.  
  今のコンパイラはすごいので高速で動くよう最適化してくれます.  
  今あるプログラムを速くしたいのであれば, 速い書き方を考えるより,
  速いアルゴリズムを考える方がずっと建設的です.  
  １ヶ月後の自分は他人です. 汚いコードを書くと自分でも何が書いてあるかわからなくなり,
  痛い目を見るので綺麗なコードを書きましょう.(他の人と一緒に書いているならなおさら)

* **メモリを意識する**  
  C言語はJavaやPython, JavaScript等の言語と違い低レイヤな言語です.
  コンピュータのメモリを直接いじることになります. なのでバグを生む可能性が非常に高いです.
  ですがそれゆえ, (プログラムによりますが)JavaやPythonの数千倍の速度で動作します.
  メモリを意識し, バグを産まずに高速なプログラムを作りましょう.

* **外部ツールを活用する**  
  上で述べたことを全て個人で管理するのは大変な労力を費やします.
  他の人が作ったそれらを管理するツールを活用しましょう.
  ここでは`git`と`clang-format`をオススメします. 使い方は各々調べてください.  

"読みやすいコードを書く"と言われても
分からないと思いますが頭の片隅に置いておいてください.  
一つ目と三つ目は他の言語を書く際にも大事なことです.  
C言語以外を書く際にも心がけましょう.

二つ目は初心者から上級者まで頭を悩まされる問題で,
特に初心者のうちはこれによるエラーやバグを多く抱えることになるでしょう.
それでもめげずに頑張りましょう!

* *__この書体で書いてあることは説明するのが難しいので説明しませんが知っている必要があります. Googleで調べるか, 聞いてください__*

# 1部. まずプログラムを書けるようになろう.
まず c++ を書く上で絶対に欠かせないことを学んでいく必要があります.
これらの要素をマスターすれば, ほとんどのプログラムが書ける様になるでしょう.  
それが "いいコード" かは別問題ですが, それは2部にまわして
まず c++ を書ける様になりましょう.

## 1. 最初のプログラム

```c++:1_1.cpp
#include <iostream>

int main()
{
    std::cout << "Hello World !" << std::endl;
    return EXIT_SUCCESS;
}
```
一行目はまだ気にしないでください. おまじないです.  
5行目で, `Hello World !`という文字列を出力しています.  
6行目で. プログラムが正常に動作し終了したことをこのプログラムを呼びたしたもの伝えています.  
5,6行目の終わりに`;`が書いてあります, これは一つの命令が終わったことを表しています.  

基本的に全てのcプログラムは`int main() {`と`}`で挟まれた部分に書いてある命令が実行されます.  
正確にいうと色々と語弊があるのですが, 今はそう解釈して先に進みましょう.

注: c++のコードではほとんどの場合スペースと改行は等価です. つまり以下のコードでも同じプログラムが出来上がります.

```c++:1_2.cpp
#include <iostream>

int main(){std::cout << "Hello World !" << std::endl;
    return EXIT_SUCCESS;}
```
が, 一目瞭然で読みづらいので`1_1.cpp`のようなコードを書きましょう.

## 2. コンソールへの出力
```c++:2_1.cpp
#include <iostream>

int main()
{
    std::cout << "test" << 1;
    std::cout << "test2" << std::endl;
    std::cout << "日本語もOK !" << std::endl;
    return EXIT_SUCCESS;
}
```
```:出力
test1test2
日本語もOK !
```
このように`std::cout`と`<<`を組み合わせることによってコンソールに出力を表示できる.  
`std::endl`は end of line を表し, 改行を示す.  
**これらを使う際には1行目の`#include <iostream>`を忘れないこと.**

## 3.コメント
```c++:3_1.cpp
#include <iostream>

int main()
{
    std::cout << "太陽は東から昇る" << std::endl; // 太陽よ西から登れ!! 
    return EXIT_SUCCESS;
}
```
```:出力
太陽は東から昇る
```
コメントは出来上がるプログラムに影響を及ぼしません.  
`//`を挿入した後の文字は, 行が終わるまで全てコメントになります.

## 4.変数, 型
ほぼ全てのプログラミング言語には変数 (オブジェクト) という概念があります.  
変数とはデータを入れておく箱のようなものです.  
ここに入れておけば後で取り出すことができるのです.  

### 基本文型

* 変数の宣言

変数を作ることを*宣言*と言い, 以下の様に書きます.

```c++
型名 変数名;
```

* 変数への代入

変数に値を設定することを, *代入*と呼び以下の様に書きます.

```c++
変数名 = 値;
```

* 変数の初期化

変数を宣言と同時に値を設定することを初期化と呼びます.

```c++
型名 変数名 = 値;
```

[参考URL : ロベールのC＋＋教室 - 第5章 変数](http://www7b.biglobe.ne.jp/~robe/cpphtml/html01/cpp01005.html)

### 型の種類

最初から定義されている型には以下の様なものがあります.

* *__`bool`型__*  
  設定できる値は, `true` と `false` の二種類で, 1bitの情報量を持ちます.
* *__`char`型__*  
  値は, -127 ~ 128 でアルファベットなどの一文字を表します.
* *__`int`型__*  
  値は実行環境によりますが大体, $-2^{31} - 1$ ~ $2^{31}$ で, 整数を表します.
* *__`unsigned int`型__*  
  値は実行環境によりますが大体, $0$ ~ $2^{32} - 1$ で, 非負の整数を表します.
* *__`long`型__*  
  値は実行環境によりますが大体, $-2^{63} - 1$ ~ $2^{63}$ で, 整数を表します.
* *__`float`型__*  
  値の範囲は複雑なので自分で調べてください, 小数を表します.
* *__`double`型__*  
  値の範囲は複雑なので自分で調べてください, 
  `float`よりも大きく, 精度の高い小数を表します.

### 例文

```c++:4_1.cpp
#include <iostream>

int main()
{
    int a = 1;  // 変数aを宣言. 型は整数型で,中身は1で
    float b = 2.4;  // 変数bを宣言! 型は小数型で中身は2.4で
    std::cout << a << std::endl;  // 1ですね
    std::cout << b << std::endl;  // 2.4ですね
    a = 2;  // aの中身を再設定!
    std::cout << a << std::endl;  // ちゃんと変わってる.
    return EXIT_SUCCESS;
}
```
```:出力
1
2.4
2
```
ここでは`a`と`b`が変数でその前の`int`, `float`が型です.  
`int`は Integer : 整数, `float`は floating point : 浮動小数点(小数) を表しており
入れて置けるものの種類を表します.  
変数において, つけた名前と内容は全く関係ありません.  
上のコードで`a`を`aplha`と置き換えても出来上がるプログラムは同じです.

変数を初めて使う時は宣言が必要で`型名 変数名 = 値`のように書きます.  
`変数名 = 値`でその変数に値を設定しなおことができます.

## 5.数字に対する演算子
[参考URL : C言語の演算子について](http://www.c-lang.org/operator.html)

```c++:5_1.cpp
#include <iostream>

int main()
{
    int a = 4;  // 変数aの宣言. 中身は4で
    int b = 2;  // 変数bの宣言. 中身は2で
    std::cout << a + b << std::endl;  // 4 + 2 = 6
    std::cout << a * b << std::endl;  // 4 × 2 = 8
    std::cout << a - b << std::endl;  // 4 - 2 = 2
    std::cout << a / b << std::endl;  // 4 ÷ 2 = 2
    std::cout << (a + b) / b << std::endl;  // (4 + 2) ÷ 2 = 3
    std::cout << 3 * 5 << std::endl;  // 数字を生のままでもOK.
    return EXIT_SUCCESS;
}
```
```:出力
6
8
2
2
3
15
```
感覚的なので割愛.  
`*`が掛け算なのは覚えておきましょう.

* *__比較演算子　`<`, `>`, `>=`, `<=`, `==`, `!=`__* 
* *__論理演算子　`&&`, `||`, `!`__*
* *__代入演算子　`+=`, `-=`, `*=`, `/=`__*

## 6.ポインタ
変数は抽象的な空間にポツンと浮いているわけではありません.  
CPUメモリ上に具体的に存在し, その場所を示す住所も存在します.  
その住所を表す型, もしくはその住所をポインタと呼びます.

多くの人にとって慣れるまで時間がかかる概念です. めげずによく考えましょう.  
わかってしまえばなんてことはありません. ただの住所です.  

### 基本構文

* "`型名`型のポインタ"を型とした変数を定義.

```c++
型名* 変数名;
```

* ポインタ型の変数が指し示す先にアクセス.

```c++
*変数名
```

* 変数のポインタを見る.

```c++
&変数名
```

### 例文


```c++:6_1.cpp
#include <iostream>

int main()
{
    int a = 1;  // 変数aを宣言
    int* pointer_of_a = &a;
    // 変数aのポインタを変数pointer_of_aとして設定.

    std::cout << a << std::endl;  // aの中身は1
    std::cout << pointer_of_a << std::endl;
    // 変数pointer_of_aの中身は人間には理解できないけど変数aの場所を表している.

    std::cout << &a << std::endl;  // aのポインタの値はずっと変わらない.

    std::cout << *pointer_of_a << std::endl;
    // "*ポインタ"で中身にアクセス !
    
    std::cout << *(&a) << std::endl;
    // aのポインタが指し示すは当然aの中身

    *pointer_of_a = 2;  //ポインタを使って変数aの値を変えよう
    std::cout << a << std::endl;  // 変わってる!
    return EXIT_SUCCESS;
}
```
```:出力
1
0x7fff547bfa48 (ここは実行するごとに変わります)
0x7fff547bfa48 (ここに住所を割り振るのはOSの仕事なので)
1
1
2
```
ポインタとは変数があるメモリの住所（場所）を表すもので`a`のポインタは`&a`で表されます.
また特定の型の変数のポインタを置いておく型として`型名*`があります.  
例えば`int`型のポインタの型は`int*`となります.  
また`*ポインタ名`でそのポインタが指し示す変数の値にアクセスできます.

[参考URL1](http://www7b.biglobe.ne.jp/~robe/cpphtml/html01/cpp01032.html)  
[参考URL2](http://www7b.biglobe.ne.jp/~robe/cpphtml/html01/cpp01033.html)  
[参考URL3](http://www7b.biglobe.ne.jp/~robe/cpphtml/html01/cpp01034.html)  


## 7.参照
概念としては別のものなのですが中身としては非常にポインタに近いです.  
これも難しいものなのですが, 非常に便利で多用します.  
イメージとしてはある変数に別の名前をつけ, その名前で "も" 扱える様にするものです.  
ですが, 知らなくても一応プログラムは書けるので, よくわからなかったら飛ばして
先に進んでもいいでしょう.  

### 基本文型

* 変数`変数名`の参照を宣言.

```c++
型名& 参照の変数名 = 型名; // 型名は"変数名"の型と同じでなくてはならない.
```

### 例文


```c++:7_1.cpp
#include <iostream>

int main()
{
    int a = 1;  // 変数aを宣言! 中身は1で初期化!
    int& reference_of_a = a;
    // 変数reference_of_aにaの参照を渡します. ややこしい.

    std::cout << a << std::endl;  // 当然1
    std::cout << reference_of_a << std::endl;
    // 変数aのように振る舞うのでaの中身が見れる.

    reference_of_a = 2;
    // 変数aのように振る舞うので, つまり変数aを2に再設定していることに! ややこしい.

    std::cout << a << std::endl;
    // なので直接いじっていないのにaの中身が変わっている.
    return EXIT_SUCCESS;
}
```
```:出力
1
1
2
```
`型名&`で"その型名の参照"の型を表します.  
`int&`は"`int`型の参照"を表す型です.  
気分としては内部にポインタが保持されていて  
参照を使おうとすると常にそのポインタが指し示す先が代わりに使われます.

## 8.if文
if文は全てのプログラム言語にあると行ってもいい文法です.
変数の中身などをチェックすることで, その値に応じた動作に分岐します.

プログラムらしくなってきました.  
もうそろそろ, それらしいものが書けるようになってきます.  

* 基本文型

```c++
if ( 条件文 ) {
    ... //条件文がtrueなら実行される.
}
```
```c++
if ( 条件文 ) {
    ... //条件文がtrueなら実行される.
}
else {
    ... //条件文がfalseなら実行される.
}
```
```c++
if ( 条件文1 ) {
    ... //条件文1がtrueなら実行される.
} else if (条件文2) {
    ... //条件文1がfalseで, 条件文2がtrueなら実行される.
} else if (条件文3) {
    ... //条件文1, 条件文2がfalseで, 条件文3がtrueなら実行される.
}
...
else {
    ... //全ての条件文がfalseの時に実行される.
}
```

`()`の中には`bool`型の値が入ります.  
よく使われるのは比較演算子によって生じる`bool`型の値でしょうか.  

### 例文


```c++:8_1.cpp
#include <iostream>

int main()
{
    int a = 3;  // 変数aを宣言!
    int b = 4;  // 変数bを宣言!
    if (a > b) {
        // 当然 3 > 4 な訳ないのでここは実行しない.
        std::cout << "aよりbは小さいです." << std::endl;
    }
    else if (a < b) {
        // 当然 3 < 4 なのでここが実行される.
        std::cout << "bよりaは小さいです." << std::endl; 
    }
    else {
        // もう当てはまるものがあったのでここはスルー
        std::cout << "aとbは同じ数です." << std::endl;
    }
    return EXIT_SUCCESS;
}
```
```:出力
bよりaは小さいです.
```

`()`の中には`bool`型が入ります.  
比較演算子を使った際出てくるのが`bool`型であることに注意しましょう.  
条件文の値が`true`であった場合`{}`の中身を実行します.  
`else if`を使うことで`if`に当てはまらなかった時に確認する.  
`else`で上の条件文全てに当てはまらなかった時に実行する命令を書くことができます.


## 9. スコープ, 変数の寿命
変数は定義したらいつまで使えるのでしょうか? プログラムが終わるまででしょうか?  
プログラム中で同じ名前の変数を複数作ることはできないのでしょうか?  

どちらも違います.
これらを明確に決める概念がスコープです.
一言で言ってしまえば`{}`で囲むことスコープを作ることができます.  
場合により`{}`を省略できるでしょうが, そんなことはするべきでないでしょう.  
可読性を著しく下げる可能性があります.  

### 基本文型


* スコープの作成

```c++
{
    // この中がスコープ
    ...
}
```

### 実例


```c++:12_1.cpp
#include <iostream>

int main {  // main関数によるスコープが発生.
    int a = 0;
    if (4 > 3) {  // if文によるスコープが発生. 
        int b = 1;  // 変数bを定義. しかし..if文によるスコープの間しか存在しない.
    } // ここで変数bは無くなってしまう. この後使おうとするとエラー.
    
    float b = 3.14;
    // 再定義することは可能. でも生まれ変わりってわけじゃない. 全くの別人.
    
    { // 自分で何もないところにスコープを作ることも可能.
        int c = 2; // 変数cを定義
        { // 何重にもスコープを作ることも可能. でもあんまり重なると見辛い.
            char d = 'D';
            std::cout << "a : " << a << std::endl;
            std::cout << "b : " << b << std::endl;  // ここは9行目のbのこと
            std::cout << "c : " << c << std::endl;
            std::cout << "d : " << d << std::endl;
            // スコープの内側から外側を見ることはできる. 逆はできない. 
        } // 変数dが消えてしまった!
        std::cout << "c : " << c << std::endl; 
        // まだcは生きてるよ!
    } // 変数cも消えてしまった..
    
    return EXIT_SUCCESS; 
    // 変数a, bが消えてしまった.. まあプログラムが終わるから当たり前だけど.
}
```
```:出力
a : 0
b : 3.14
c : 2
d : D
c : 2
```

## 10.while文
ループを扱う文法です.  
同じ処理を幾度も繰り返すというのはプログラムに置いて非常によくあることです.

* 基本文型

```c++
while( 条件文 ) {
    ...  // 条件文に当てはまる限り, 何回でも実行します.
}
```

```c++:9_1.cpp
#include <iostream>

int main()
{
    int a = -1;  // 変数aを宣言! -1で初期化!
    while(a < 5) {
        a += 1;  // aに1を足す.
        std::cout << a << std::endl;
        // aが最初-1なのでaが0, 1, 2, 3, 4, 5の時と6回呼び出される.
    }
    std::cout << a << std::endl; 
    // 念のためもう一度出力. 変わっていませんね!
    return EXIT_SUCCESS;
}
```
```:出力
0
1
2
3
4
5
5
```
while文は`()`内の`bool`型変数の値が`true`である時, `{}`の中身を何度でも繰り返します.  
なお, while文の`{}`中で作った変数は１ループ毎に消えてしまいます.

### break

以下のように`break`を使えば`while`によるループから強制的に抜け出すことができます.  
ただし抜け出すループは一つだけです.

```c++:9_2.cpp
#include <iostream>

int main()
{
    int a = -1;  // 変数aを宣言! -1で初期化!
    while(a < 5) {
        a += 1;  // aに1を足す.
        std::cout << a << std::endl;
        if (a > 2) {
            break;
            // やっぱり気が変わったので3になったらやめる.
        }
    }
    std::cout << a << std::endl; // ちゃんと3
    return EXIT_SUCCESS;
}
```
```:出力
0
1
2
3
3
```

後述するfor文があるので, 個人的にwhile文は以下のような形式で使うことが多い気がします.

```c++
while(true) {  // trueで固定しているのでbreakを使わない限り, ぬけだすことはない.
    ...  // なんらかの処理
    if (条件文1) {
        break;
    }
    if (条件文2) {
        break;
    }
    ...
    if (条件文n) {
        break;
    } // つまり条件文1~nのどれか一つでも満せばループ終了
}
```

### continue

`continue`を使えばループの次の週へとジャンプすることができます.

```c++:9_3.cpp
#include <iostream>

int main()
{
    int a = -1;  // 変数aを宣言! -1で初期化!
    while(a < 5) {
        a += 1;  // aに1を足す.
        if (a == 2) {
            continue;
            // aが2の時は表示せずに次に進もうっと.
        }
        std::cout << a << std::endl;
    }
    std::cout << a << std::endl;
    return EXIT_SUCCESS;
}
```
```:出力
0
1
3 (2が飛ばされてる!)
4
5
5
```

## 11.for文
for文もループを扱う文ですがwhile文より少し複雑で自由度が高いです.  
ですがその自由度に比べてfor文が使用される際はほぼ決まった数通りの形で書かれています.  
まずはその定型文を覚えてしまえい, 追い追い正確な定義を覚えていけば良いでしょう.

* 基本文型

```c++:
for (文1; 条件文; 文2) {
    ...  // 条件文に当てはまる限り何度でも実行されます.
}
```
こう書いたfor文は以下のwhile文とほぼ同義です.

```c++:
{
    文1;
    while (条件文) {
        ...  // 条件文に当てはまる限り何度でも実行されます.
        文2;
    }
}
```
全体が`{}`で囲われているのはスコープに関係し, 文1で生成した変数がどこまで有効かということに関わってきます.  
文1で作った変数はループが終わり次第消えてしまうということだけ覚えておきましょう.

```c++:11_1.cpp
#include <iostream>

int main()
{
    for (int i = 0; i < 5; i++) {
        std::cout << "今" << i + 1 << "回目のループです." << std::endl;
        // i が 0, 1, 2, 3, 4と5回呼び出されている!
    }
    return EXIT_SUCCESS;
}
```
```:出力
今1回目のループです.
今2回目のループです.
今3回目のループです.
今4回目のループです.
今5回目のループです.
```
先ほどほとんどのfor文は決まった数パターンの形しかないと言いましたが, この形はその中でも最も多く使われている形です.  
最初は何が書いてあるかわからないでしょうが, じっくりみて内容を確認してください.
上のwhileで書き換えた形と照らし合わせれば納得できるでしょう.

ちなみに`break`と`continue`はfor文でも使えます. ただ`continue`を使う際は上のwhileとの書き換えが成り立たなくなります.  
`continue`によって次のループへ飛んでも, 文2が無視できず, 実行されるという点です.  
モノポリーで次の鉄道駅まで飛ぶときにGOマスを飛ばしても$200受け取れるのと同じと言えば通じる人には通じるでしょうか. `continue`は"刑務所へ行く"カードとは違うのです.

## 12. 関数その1
高級プログラミング言語であれば絶対にあると言っても過言ではない文法です.  

関数は自分で定義し, 呼び出すことができます.  
複雑な操作を何度もする場合, やる回数分だけ書くのは効率的ではありません.  
そこでひとまとまりの操作を関数という形でまとめておくのが関数というものです.  

まず戻り値の型が`void`の関数(まだ何を言っているかわからないと思います)見ていきましょう.  

### 基本文型

* 戻り値が`void`の関数の定義

```c++
void 関数名 (型名1 引数名1, 型名2 引数名2, ... , 型名n 引数名n) {
    ... //実行する内容.
}
```
* 関数の呼び出し

```c++
関数名(引数1, 引数2, ... , 引数n);
```

### 実例

基本文型を見てもピンとこないと思うので実例を見てみましょう.  

```c++:12_1.cpp
#include <iostream>

// 円の半径を入力して, 面積を出力させる関数.
void sayCircleArea(float rad) { // rad には ()の中に入れた数字が入る.
    // 呼び出す度に以下の3行が実行される.
    float area = rad * rad * 3.141592; // 呼び出す度変数 area がつくられる.
    std::cout << "半径 " << rad << "の円の面積は" << area
              << "です." << std::endl;
}
// ここで変数 area　が消える.

int main()
{
    sayCircleArea(1); // 半径1の円の面積を出力.
    sayCircleArea(2); // 半径2の円の面積を出力.
    sayCircleArea(3); // 半径3の円の面積を出力.

    return EXIT_SUCCESS;
}
```
```:出力
半径 1の円の面積は3.14159です.
半径 2の円の面積は12.5664です.
半径 3の円の面積は28.2743です.
```
以上のように作業をまとめて, 見やすくしています.  
このように行数を短くすることは大事です.

まだよくわからないと思うので実際にプログラムが実行された時にたどる行を見ていくことにします.

1. 13行目を実行, すなわち関数`sayCircleArea`に引数`1`を渡して, 実行.
2. 5, 6, 7, 8行目を実行. 5行目はコメントなので無視されますが.
3. 14行目を実行, 関数`sayCircleArea`に引数`2`を渡して, 実行.
4. 5, 6, 7, 8行目を実行. 引数`rad`には`2`が入っている.
5. 14行目を実行, 関数`sayCircleArea`に引数`3`を渡して, 実行.
6. 5, 6, 7, 8行目を実行. 引数`rad`には`3`が入っている.

という流れになっています.

つまり以下のコードと同じ動きをします.

```c++:12_2.cpp
#include <iostream>

int main()
{
    {
        float rad = 1;
        float area = rad * rad * 3.141592;
        std::cout << "半径 " << rad << "の円の面積は" << area
                  << "です." << std::endl;
    } // 半径1の円の面積を出力.
    {
        float rad = 2;
        float area = rad * rad * 3.141592;
        std::cout << "半径 " << rad << "の円の面積は" << area
                  << "です." << std::endl;
    } // 半径2の円の面積を出力.
    {
        float rad = 3;
        float area = rad * rad * 3.141592;
        std::cout << "半径 " << rad << "の円の面積は" << area
                  << "です." << std::endl;
    } // 半径3の円の面積を出力.

    return EXIT_SUCCESS;
}
```
`12_1.cpp`の方が何をやっているか分かりやすいし, 行数も短く済んでいますね.  

なおコメントでも書いてありますが,  
関数の中で宣言した変数はその関数が終了する度にリセットされます.

次のセクションでも関数を扱いますので慣れていきましょう.

## 13. 関数その2
戻り値にバリエーションを持たした関数を見ていきましょう.

関数の中で計算した値を関数を呼び出した側で, 使いたいとことがあると思います.  
そのような時は, "戻り値"を使います. 具体的な使い方を見て見ましょう.

### 基本例文

* 関数の定義

```c++
戻り値の型 関数名 (型名1 引数名1, 型名2 引数名2, ... , 型名n 引数名n) {
    ... //実行する内容.
    return 戻り値;
}
```
* 関数の呼び出し

```c++
関数名(引数1, 引数2, ... , 引数n);
```

### 例文

```c++:13_1.cpp
#include <iostream>

// 戻り値はfloat型, つまり小数.
float max(float a, float b) {  // 引数は何個でもよい
    if (a > b) {
        return a;  
        // 別にreturn は最後じゃなくてもOK!
    }
    else {
        return b;
        // returnは呼んだ瞬間, 関数の処理が終わって呼び出し元に戻ります.
    }
    std::cout << "ここまではこない" << std::endl;
}

int main()
{
    std::cout << max(3.141592, 2.718) << std::endl;
    
    return EXIT_SUCCESS;
}
```
```:出力
3.141592
```
関数の戻り値は, 18行目の様に変数の様に扱えます.  
数学の関数の様に $f(x) + g(y) = ?$ みたいな感覚で使えばいいです.  
以下の様な例を見るとわかりやすかもしれません.

```c++:13_2.cpp
#include <iostream>

// 戻り値はfloat型, つまり小数!
float f(float x) {
    return x * x + 2 * x + 3;
}

int main()
{
    std::cout << f(3) + f(5) << std::endl;
    return EXIT_SUCCESS;
}
```
```:出力
56
```

気がついた方もいると思いますが, 今まで書いていた`int main() { ... }`も関数の宣言をしています.  
これは使わないと慣れません. 使い倒しましょう.

## 14. 構造体
いくつかのデータをまとめて使いたいときがあるでしょう.
その役割を果たすのが構造体です.

構造体の宣言は新しい型を作ります.  
構造体の宣言と, 宣言した型を使って宣言した変数を区別するようにしましょう.

### 基本文型

* 構造体の宣言

```c++
struct 構造体名 {
    型名1 メンバ変数名1;
    型名2 メンバ変数名2;
    ...
    型名n メンバ変数名n;
};
```
* 構造体を型とした変数の宣言

```c++
構造体名 変数名;
```
* 構造体を型とした変数のメンバ変数へのアクセス.

```c++
変数名.メンバ変数名
```

### 例文


```c++:14_1.cpp
#include <iostream>

struct Human {
    int age;
    float weight;
};

int main()
{
    Human A;  // 変数Aの宣言
    Human B;  // 変数Bの宣言
    
    A.age = 18;  // 構造体変数Aのageというメンバ変数を18で設定.
    A.weight = 70.3;  // 構造体変数Aのweightというメンバ変数を70.3で設定.

    B.age = 21;  // 構造体変数Bのageというメンバ変数を21で設定.
    B.weight = 54.3;  // 構造体変数Bのweightというメンバ変数を54.3で設定.

    std::cout << "Aの年齢 : " << A.age << std::endl;
    std::cout << "Aの体重 : " << A.weight << std::endl;
    std::cout << "Bの年齢 : " << B.age << std::endl;
    std::cout << "Bの体重 : " << B.weight << std::endl;
    // Aのメンバ変数とBのメンバ変数の値がしっかりと違います.
    
    return EXIT_SUCCESS;
}
```
```:出力
Aの年齢 : 18
Aの体重 : 70.3
Bの年齢 : 21
Bの体重 : 54.3
```
上の文でわかるように構造体の宣言時(3~6行目)にそこ変数ができるわけではないことに注意しましょう.  
構造体を型として変数を宣言することで初めて実体ができます.

## 15. クラス
クラスはcからc++に追加された最も大きい要素と言えるかもしれません.  
機能としては構造体をさらに拡張したものと言えますが, その役割は大きく違います.  
c++を勉強するにあたって最も理解するのが難しい概念かもしれませんが頑張りましょう.

クラスはオブジェクト思考という考え方に基づいて設計されています.  
文法を覚えただけでは使いこなせたとは言えないと思われます.  
何度も使って良い使い方を覚えましょう.

### 基本文型

#### クラスの宣言


```c++
class クラス名 {
public:
    型名1 公開メンバ変数名1;
    ...
    型名n 公開メンバ変数名n;
private:
    型名1 秘匿メンバ変数名1;
    ...
    型名n 秘匿メンバ変数名n;

public:
    クラス名(型名 引数名1, ...) {  // コンストラクタの宣言
        ...
    }
    型名 公開メンバ関数名1() {  // 公開メンバ関数の宣言
        ...
    }
    ...
    型名 公開メンバ関数名n() {
        ...
    }
private:
    型名 秘匿メンバ関数名1() {  // 秘匿メンバ関数の宣言
        ...
    }
    ...
    型名 秘匿メンバ関数名n() {
        ...
    }
};
```
#### クラスを型とした変数の宣言

* コンストラクタが引数を取る場合

```c++
クラス名 変数名(コンストラクタの引数1, ... コンストラクタの引数n);
```
* コンストラクタが引数を取らない場合

```c++
クラス名 変数名;
```

#### クラスを型とした変数のメンバ関数を呼ぶ

```c++
変数名.メンバ関数名(引数1, ... 引数n);
```
メンバ変数のアクセス仕方は構造体と一緒です.

コンストラクタとはこのクラスを型とした変数が宣言された時に実行される命令です.  
おおよそ関数のようなものと考えれば良いですが, 値を返しません.  
主にメンバ変数を初期化(設定)するのに使います.

### 例文

```c++:15_1.cpp
#include <iostream>

class Human {
public:
    float height;  // 身長は見たらわかるので公開にしておきましょう.
private:
    float weight;  // その他の部分は見てもわからない...
    int age;
    int personality; // 0が正直, 1が嘘つき

public:
    // コンストラクタ
    Human(int age_, float weight_, float height_, int personality_) {
        // コンストラクタでは, 自分のメンバ変数に普通にアクセスできる.
        age = age_;
        weight = weight_;
        height = height_;
        personality = personality_;
    }

    void sayAge() {
        if (personality == 0) { // 正直なら
            std::cout << "私は" << age << "歳です." << std::endl;
            // メンバ関数内でも, 自分のメンバ変数に普通にアクセスできる.
        }
        else {  // もし嘘つきなら...
            std::cout << "私は" << 100000 + age << "歳です." << std::endl;
        }
    }
    
    void sayWeight() {
        if (personality == 0) { // 正直なら
            std::cout << "私は" << weight << "kgです." << std::endl;
        }
        else {  // もし嘘つきなら...
            std::cout << "私は" << 50000 << "tです." << std::endl;
        }
    }
    
    void sayPersonality() {
        std::cout << "私は正直者です." << std::endl;
    }
};

int main()
{
    Human A(18, 60.3, 174.5, 0);
    Human B(55, 58, 168, 1);
    
    // 年齢, 体重, 性格は秘匿されているのでクラスの内側からしか見れない.
    A.sayAge();
    A.sayWeight();
    A.sayPersonality();
    
    // heightは公開メンバ変数なので, アクセスできる.
    std::cout << "Aの身長は" << A.height << "cmです". << std::endl;

    // 年齢, 体重, 性格は秘匿されているので嘘をつかれてもわからない.
    B.sayAge();
    B.sayWeight();
    B.sayPersonality();

    // heightは公開メンバ変数なので, アクセスできる.
    std::cout << "Bの身長は" << B.height << "cmです." << std::endl;

    return EXIT_SUCCESS;
}
```
```:出力
私は18歳です.
私は60.3kgです.
私は正直者です.
Aの身長は174.5cmです.
私は100055歳です.
私は50000tです.
私は正直者です.
Bの身長は168cmです.
```
コンストラクタではプロフィールを設定しています.  
このように秘匿されたメンバ変数に外部からアクセスすることはできません.  
この例では秘匿されたメンバ変数がなぜ必要かわかりづらいので, 次の例を見ましょう.

```c++:15_2.cpp
#include <iostream>

class Counter {
private:
    int count;
public:
    Counter() {
        count = 0;
    }
    void update() {
        count += 1;
    }
    
    int getCount() {
        return count;
    }
};

int main()
{
    Counter counter;
    
    float a = 1.0;
    while (a > 0.005) {
        a *= 0.3;
        counter.update();
    }
    std::cout << counter.getCount() << std::endl;

    return EXIT_SUCCESS;
}
```
```:出力
5
```
このように外からいじって欲しくない時にメンバ変数を秘匿するのです.  
この場合はメンバ変数のcountをいじられると本来の役割を果たせなくなってしまいますね.  
内部にポインタの変数を持つクラスの場合, それをいじられてしまうとエラーを起こす可能性もあります.  

このように外から見えて欲しくない変数を作りたい場合が多々ありますので, そういう場合は`private:`を使います.  

**また, オブジェクト思考の下ではクラスというものはある程度独立性を持つべきです.  
基本外から見える必要のないものは秘匿しましょう.  
もし頻繁に外から内部のメンバ変数に(例えそれがpublicだとしても)アクセスしたい場合は設計を考え直した方が良いでしょう.  
そういう役割は構造体に任せるべきです.**

今行ったことを否定するようですが, 実はクラスの全ての機能は構造体でも同様に扱うことができます.  
しかし, だからと言って同じように使うべきではありません.  

基本的にはコンストラクタ以外のメンバ関数を作りたいと思った時はクラス,  
公開メンバ変数のみでできたものは構造体,  
と使い分けましょう.

## 16. 配列
同じ型の変数を同時にたくさん扱う場合というのがあります.  
例えば, 数列の値を保存しておきたい時に`a1`, `a2`, `a3`, ...とたくさん変数を作っておくのは面倒だし, いくつまで必要になるかをプログラムを書く際に知っている必要があります.  
そんな時に一つの変数名を使って, 複数の変数を同時に管理する方法が配列です.

c++には配列と呼ばれるものが3つあります.  
1つはcスタイルのもの.  
残りの2つがc++で新たに追加されたものとなります.  

どれもよく使いますが, まずはcスタイルのものを使えるようになりましょう.

### 基本文型

* 宣言

```c++
型名 変数名[配列の長さ];
```
* 長さnの配列を値を設定しつつ宣言する.

```c++
型名 変数名[n] = {変数1, 変数2, ... 変数n};
型名 変数名[] = {変数1, 変数2, ... 変数n};
型名 変数名[]{変数1, 変数2, ... 変数n}; // 3行とも同じ意味
```

* i番目にアクセス(ただし0から数える)

```c++
変数名[i]
```

### 例文

```c++:16_1.cpp
#include<iostream>

int main()
{
    int a[10]; //配列aを宣言.
    
    // フィボナッチ数列を作ってみる.
    a[0] = 1;
    a[1] = 1;
    for (int i = 2; i < 10; i++) {
        a[i] = a[i - 1] + a[i - 2];
    }
    
    for (int i = 0; i < 10; i++) {
        std::cout << "a[" << i << "] は " << a[i] << "です." << std::endl;
    }
    return EXIT_SUCCESS;
}
```
```:出力
a[0] は 1です.
a[1] は 1です.
a[2] は 2です.
a[3] は 3です.
a[4] は 5です.
a[5] は 8です.
a[6] は 13です.
a[7] は 21です.
a[8] は 34です.
a[9] は 55です.
```

注意しなければならないのは`int a[10];`と配列を宣言した時に,  
使える様になるのは`a[0], a[1], ..., a[8], a[9]`の計１０個だということに注意しましょう.
間違えて`a[10]`などを使おうとすると予期せぬ挙動を取ります.

## 17. マクロ
c++ にはマクロと呼ばれる仕組みがあり, コンパイル時に解釈され実行されます.
なんのことだかわからないとは思いますが. 実は毎度最初に書いていた`#include <iostream>`もマクロです.  

具体的には`#`から始まっている行がマクロとなります.  
その種類はたくさんありますが, ここでは`#include`のみ扱おうと思います.

`#include`マクロはその後ろに書いたファイルを読み出し, 書いてある場所にベタ書きします.  

* 例

```c++
#include <iostream> // <>で囲むとあらかじめ用意されているライブラリにアクセスする.
#include "test.txt" // ""で囲むと相対パスとしてコンパイルした場所から探す.
```

### 例文


```:example.txt
void test() {
    std::cout << "ちゃんと読み込まれています" << std::endl;
}
```
```c++:17_1.cpp
#include <iostream>

#include "example.txt"

int main()
{
    test(); // 定義していないのに呼び出したとしてコンパイルエラーになりそう...
    // だけどexample.txtに書いてあるのをコピーしたから大丈夫.
    return EXIT_SUCCESS;
}
```
```:出力
ちゃんと読み込まれています
```

つまりコンパイル時に, は以下の様なコードとして認識されているのです.

```c++
// -*- C++ -*-
//===--------------------------- iostream ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
... // 以下iostreamの中身が続くがここでは省略.

void test() {
    std::cout << "ちゃんと読み込まれています" << std::endl;
}

int main()
{
    test(); // 定義していないのに呼び出したとしてコンパイルエラーになりそう...
    // だけどexample.txtに書いてあるのをコピーしたから大丈夫.
    return EXIT_SUCCESS;
}
```

10行目までは, `iostream`の中身が展開されています.  
12, 13, 14行目は`example.txt`の中身が展開されています.

このコードを見ればうまく動くのも納得ですね.

この様に`#include`マクロは他のファイルから道具を取ってくる時に使われます.  
`#include <iostream>`も`std::cout`などの道具をコピーしてきているということなのです.  
これからは気持ちよく`#include`を使えますね.

## 1部を終えて

ここまでで1部が終わり, c++のプログラムが(少なからず)書ける様になったと思います.  
ここらで, マインスイーパの一つでも作って見てはいかがでしょうか.
それに必要な入力の方法を紹介していなかったので, ここでします.

```c++
#include <iostream>

int main()
{
    int a; // 変数を先に宣言しておく.
    std::cin >> a; // 結構どんな型でもよしなにしてくれる.
    std::cout << a << "が入力されました" << std::endl;

    return EXIT_SUCCESS;
}
```

以上の様な方法でプログラムの実行時に変数に値を設定することができます.

しっかりとしたプログラムを書き出す様になるとあまり
コマンドラインから直接入力する様なインターフェースを使わなくなってくるので,
上記の様な入力をしなくなっていくかもしれませんが, 
とりあえず覚えておくといいでしょう.
